{
  "dapps": [{
    "name": "asteria",
    "scope": "txpipe",
    "repository_url": "https://github.com/txpipe/asteria",
    "blueprint_url": "https://github.com/txpipe/asteria/blob/main/onchain/src/plutus.json",
    "published_date": 1727787600,
    "readme": "# Asteria\n\nA Cardano bot challenge to showcase the capabilities of the eUTxO model.\n\n## Mechanics\n\nIn this bot challenge you compete by moving a ship (your bot) through a 2D grid. The ship that reaches the center is allowed to collect the rewards.\n\nShips are implemented as UTxOs with a datum holding a pair of (x, y) coordinates that represent their position in the 2D grid. To move a ship, a transaction must consume the UTxO and create a new one with holding the new position.\n\n![grid](https:\/\/github.com\/txpipe\/asteria\/assets\/653886\/d5d35b42-b554-4eaa-a798-84fe7b0b9787)\n\nMovement of the ships is constrained by a _Space-Time_ on-chain script that limits their velocity. Strictly speaking, the max distance that a ship can move in any given transaction has a constant upper bound. Distances are defined using [Manhattan distance] to simplify the math.\n\n![move tx](https:\/\/github.com\/txpipe\/asteria\/assets\/653886\/ddcbc786-8947-4c0a-b0bc-4cd7de1bcd0f)\n\nMovement of the ships is also constrained by a _fuel_ token that is required for any change in position. An specifc amount of _fuel_ is required per distance unit. The lack of the required fuel amount will block the movement of the ship.\n\n![gather tx](https:\/\/github.com\/txpipe\/asteria\/assets\/653886\/5c3af5bc-5aad-4598-b35e-90e0729e82df)\n\nTo accumulate fuel, ships must _gather_ these tokens which are distributed randomly across the same grid. To gather a fuel token, your ship needs to be in the same coordinates as the fuel.\n\nTo create a ship, a participant must mint the corresponding NFT from the valid policy id. A minimum amount of ADA will be requried for the mint. This ADA used to mint the ships will be increment the rewards locked for the winner. The initial position of the ship is decided by the player but is contrainted to the external boundary of the grid.\n\nA unique UTxO will be place at the center of the grid to hold the rewards for the winner of the challenge. To claim rewards, a ship must be located at the center of the grid. Each claim is allowed to collect 1\/2 of the total rewards.\n\n## Backstory\n\n\/\/ TODO\n\n## Getting started\n\n\/\/ TODO\n\n## Monitoring progress\n\nWe have a basic visual 2D map that allows you to show the position of all the ships and fuel in real-time (updated at each block). We encourage developers to create their own visualizers, we'll showcase any project in the homepage of the challenge."
  },{
    "name": "hello_world",
    "scope": "ctf",
    "repository_url": "https://github.com/vacuumlabs/cardano-ctf",
    "blueprint_url": "https://github.com/vacuumlabs/cardano-ctf/blob/main/00_hello_world/plutus.json",
    "published_date": 1727787600,
    "readme": "# hello_world\n\nSo, you managed to install everything and now are eager to try your hands on the\nreal stuff. You are in the right place!\n\nThe validator in this task simply locks given ADA and you have to provide the\ncorrect password to unlock it. However, something is wrong and the unlocking of\nthe funds fails with an error:\n\n```\nerror: Uncaught (in promise) \"Redeemer (Spend, 0): The provided Plutus code called 'error'.\\n\\nExBudget {\\n    mem: 21485,\\n    cpu: 8262844,\\n}\\n\\n\"\n```\n\nThis error means that the validator does not validate your transaction. Can you\nfind out why and unlock the funds?\n\n## How to solve the challenges\n\nEach challenge consists of 2 files that you should interact with:\n\n- The validator, located in\n  [validators\/hello_world.ak](.\/validators\/hello_world.ak)\n- The off-chain code, located in\n  [scripts\/player_template.ts](.\/scripts\/player_template.ts)\n\nThe validator code is read only ‚Äî you are not supposed to modify it, you are\nsupposed to exploit it. The off-chain is divided into 3 parts:\n\n1. Setup ‚Äî this part setups the vulnerable scenario. This means deploying the\n   smart contracts, minting NFTs if needed, ... You should not make changes to\n   this part of the file. Setup is done by calling the `setup` function from\n   [task.ts](.\/scripts\/task.ts).\n2. Interaction part ‚Äî this is the only part that you need to edit. All your\n   exploits should go here. Usually, this part already includes an example\n   interaction which can get you going faster but is not sufficient just yet.\n   This code interacts with the smart contract in some way, but does not exploit\n   the vulnerability. This part is located in the\n   [player_template.ts](.\/scripts\/player_template.ts) file. To play, we\n   recommend keeping the template as is and **copying it** into a file called\n   `player.ts` which you can then freely edit.\n3. Tests ‚Äî the tests verify whether you correctly achieved your goal. Tests are\n   done by calling the `test` function from the [task.ts](.\/scripts\/task.ts). Do\n   not modify this part.\n\n   Note: It may be possible to satisfy the tests by not exploiting the contract\n   the way it was intended to. Especially later in the more complex scenarios,\n   there may be multiple paths to achieve the same goal. If you think you came\n   up with a unique attack, [drop us a line](..\/README.md#feedback). We would\n   love to hear about that!\n\nThe above parts communicate through a structure called `GameData`. It is created\nduring the setup, and it contains everything you need for solving the challenges\nand everything that the tests require. You should not modify it. The tests may\nrequire additional info contained within a `TestData` structure. You will be\nspecifically instructed on how to modify it if needed. It is not needed for this\ntask.\n\nTo start, you can compile the validators by running `aiken build` in the root of\nthe task. Then you can run the sample code by running\n`deno run --allow-net --allow-read .\/scripts\/run.ts`. Run is our wrapper that\ncalls the function `play` from `player.ts` (if you did not copy\n`player_template.ts`, it will not work).\n\nThe wrapper first tests your code in the Lucid emulator. If all the tests inside\nthe emulator pass, the code is tested one more time against the testnet. The\nemulator provides early feedback so that you do not need to wait for all the\ntransactions being validated and accepted on the actual blockchain. Once you\nsolve the task, though, only the testnet offers a real-world environment and so\nit is really important to pass there as well. This default behavior can be\nchanged in the `common\/offchain\/config.ts`.\n\nThe goal of each task is to pass all the tests by editing the editable parts of\noff-chain code. You will get a _green_ congrats message once you get there.\n\nWith all that said, good luck and have fun!"
  },{
    "name": "contracts",
    "scope": "sundae",
    "repository_url": "https://github.com/SundaeSwap-finance/sundae-contracts",
    "blueprint_url": "https://github.com/SundaeSwap-finance/sundae-contracts/blob/main/plutus.json",
    "published_date": 1727787600,
    "readme": "# sundae-contracts\n\nThis repository contains version 3 and onward of the smart contracts for the SundaeSwap Protocol.\n\n> Note: Version 1 consisted of the closed source Plutus v1 contracts written in 2021; Version 2 consisted of a short lived attempt to rewrite them in Plutus v2, before we decided to migrate to Aiken. It's also convenient, as we also released a \"v2\" of the UI, and so many were getting confused when we spoke of the \"v2 contracts\", not understanding the difference.\n\nLink to formal V3 whitepaper: https:\/\/cdn.sundaeswap.finance\/SundaeV3.pdf\n\n## Layout\n\nThe repository is organized as follows:\n - validators: The core validator logic for all contracts\n   - tests: Any tests for the overall validator logic, against a fully constructed script context\n - lib:\n   - types: Any type definitions (such as datums and redeemers) used elsewhere in the code\n   - calculation: The math-heavy calculations for each order type\n   - tests: Any tests, or sample data generators, related to individual components of the smart contracts\n - lucid: Some lucid skeleton work for testing and benchmarking the contracts end to end\n\n## Validators\n\nA brief overview of the validators defined in this repo:\n - order.ak: This is the current \"order\" contract, which lets users lock funds to signal their intent to interact with the sundaeswap protocol\n - stake.ak: This is a stake withdrawal used by the order.ak for the \"zero withdrawal\" trick to save on execution units\n - pool.ak: This is the core CPP-AMM Liquidity pool logic\n - settings.ak: This governs global protocol settings\n - pool_stake.ak: This is a staking validator that can be attached to liquidity pools by the treasury administrator; it pays any staking rewards to the Sundae Treasury according to the same logic as pool protocol fees\n\nOther orders and pool types added in the future might change the structure of these folders.\n\n## Contract architecture\n\nAt the highest level, the Sundae v3 protocol is implemented as an extensible set of pool and order contracts, which implement batched AMM order execution and collect protocol fees for doing so.\n\nSome notable differences from the v1 contracts:\n - Scooper fees (now generically called protocol fees) are collected at the pool UTXO, and can be withdrawn to a specific treasury address by a treasury administrator.\n - A pool enforces a \"start time\", before which no trades can happen.\n - A pool has a starting fee, which decays over some period of time, to a final fee.\n - A pool is not dependent on a specific order contract, only the structure of the order datum.\n - An order can be owned by a generic multisig, including a \"script\" requirement.\n - An order can donate funds to the pool, useful for protocols that want to build incentives for users\n - An order can be defined as a \"strategy\", deferring the details of the order until a later date, so long as its signed by some public key\n - The stake address attached to a pool can be updated by a treasury administrator\n - The rewards earned by a pool can be withdrawn to the treasury as protocol fees\n - Scoopers are not issued tokens to authorize them; they are defined in a global settings datum\n - Scoopers define the order inputs are processed, rather than relying on what order they appear in the transaction\n - And more, as defined in our whitepaper above"
  },{
    "name": "marketplace",
    "scope": "jpg-store",
    "repository_url": "https://github.com/jpg-store/contracts-v3",
    "blueprint_url": "https://github.com/jpg-store/contracts-v3/blob/main/plutus.json",
    "published_date": 1727787600,
    "readme": "<div align=\"center\">\n  <img src=\"https:\/\/github.com\/jpg-store\/contracts-v3\/blob\/main\/img\/icon.png?raw=true\" alt=\"Jpg Store\" height=\"150\" \/>\n\n  <hr \/>\n    <h2 align=\"center\" style=\"border-bottom: none\">\n      <a href=\"https:\/\/jpg.store\">jpg.store<\/a> v3 contracts powered by <a href=\"https:\/\/aiken-lang.org\">Aiken<\/a>\n    <\/h2>\n\n[![Licence](https:\/\/img.shields.io\/github\/license\/jpg-store\/contracts-v3)](https:\/\/github.com\/jpg-store\/contracts-v3\/blob\/main\/LICENSE)\n[![Tests](https:\/\/github.com\/jpg-store\/contracts-v3\/actions\/workflows\/tests.yaml\/badge.svg?branch=main)](https:\/\/github.com\/jpg-store\/contracts-v3\/actions\/workflows\/tests.yaml)\n\n  <hr \/>\n<\/div>\n\nThis repo contains the smart contracts powering jpg.store. 100% written in\nAiken.\n\nThere are two main contracts: Bid and Ask. Bids are offerings in ADA in exchange\nfor a given asset, asks are assets in exchange for ADA.\n\nAsk bulk-purchase currently maxes out at **54** assets in a single transaction when running\nthe e2e tests.\n\n## Ask\n\n### Important\/Breaking changes\n\nCheck out our [medium post](https:\/\/medium.com\/@jpgstorenft\/unveiling-the-next-gen-smart-contract-update-for-jpg-store-2f883c913979)\n\n## Development\n\n- install [Aiken](https:\/\/aiken-lang.org\/installation-instructions)\n- `aiken check`\n- `cd e2e && deno task e2e`\n\n> If you change any Aiken code please run `aiken build` and commit the `plutus.json` file."
  },{
    "name": "hydra-plutus",
    "scope": "hydra",
    "repository_url": "https://github.com/cardano-scaling/hydra",
    "blueprint_url": "https://github.com/cardano-scaling/hydra/blob/master/hydra-plutus/plutus.json",
    "published_date": 1727787600,
    "readme": "# <p align=\"center\">Hydra :dragon_face:<\/p>\n\n<div align=\"center\">\n  <p>Implementation of the Hydra scalability protocols.<\/p>\n  <a href='https:\/\/github.com\/cardano-scaling\/hydra\/actions'><img src=\"https:\/\/img.shields.io\/github\/actions\/workflow\/status\/cardano-scaling\/hydra\/ci-nix.yaml?branch=master&label=Tests&style=for-the-badge\" \/><\/a>\n  <a href='https:\/\/github.com\/cardano-scaling\/hydra\/pkgs\/container\/hydra-node'><img src=\"https:\/\/img.shields.io\/github\/actions\/workflow\/status\/cardano-scaling\/hydra\/docker.yaml?branch=master&label=Docker&style=for-the-badge\" \/><\/a>\n<\/div>\n\n## :sunrise_over_mountains: Introduction\n\nHydra is the layer-two scalability solution for Cardano, which aims to increase\nthe speed of transactions (low latency, high throughput) and minimize\ntransaction cost.\n\nThis repository contains the implementation for the Hydra [Head\nprotocol](https:\/\/eprint.iacr.org\/2020\/299.pdf). Most prominently, it contains a\n`hydra-node`, which runs a simplified (coordinated) Hydra Head protocol,\nconnects to other `hydra-node`s, interfaces the Cardano blockchain and provides an\nAPI to clients such as the included example terminal user interface `hydra-tui`.\n\n:rotating_light: Mainnet Availability :rotating_light:\n\nThe Hydra Head protocol version 0.10.0 or newer is compatible with the Cardano\nmainnet, which means it is possible to run a `hydra-node` on mainnet using real\nfunds.\n\nBefore running a `hydra-node` to take part in the Hydra Head protocol,\ndevelopers are strongly encouraged to review the [known issues][known-issues] in\nthe documentation in order to understand the current limitations and the\npossible consequences.\n\nBy using Hydra Head protocol version 0.10.0 or newer, you understand the\nprotocol is in development and that use of the `hydra-node` on mainnet is\nentirely at your own risk.\n\nYou also acknowledge and agree to have an adequate understanding of the risks\nassociated with use of the Hydra Head protocol version 0.10.0 or newer and that\nall information and materials published, distributed or otherwise made available\non hydra.family and Hydra Github Repository is available on an ‚ÄòAS IS‚Äô and ‚ÄòAS\nAVAILABLE‚Äô basis, without any representations or warranties of any kind. All\nimplied terms are excluded to the fullest extent permitted by law. For details,\nsee also sections 7, 8 and 9 of the [Apache 2.0 License][license].\n\n[known-issues]: https:\/\/hydra.family\/head-protocol\/docs\/known-issues\n[license]: .\/LICENSE\n\n## :rocket: Getting started\n\nThe quickest way to get a `hydra-node` running is to use our [docker\nimages](https:\/\/github.com\/orgs\/input-output-hk\/packages?repo_name=hydra).\n\n```sh\ndocker pull ghcr.io\/cardano-scaling\/hydra-node\ndocker run --rm ghcr.io\/cardano-scaling\/hydra-node --help\n```\n\nGet started with the [user manual üìñ](https:\/\/hydra.family\/head-protocol\/docs\/getting-started)!\n\n## :rainbow: Features\n\n- [x] Coordinated Hydra Head protocol\n- [x] Single Head per hydra-node\n- [x] Network statically configured, direct TCP connections\n- [x] WebSocket\/HTTP-based API\n- [x] Example terminal user interface client\n- [x] Cardano-node integration via Direct connection\n- [x] Locally persisted Head state\n- [x] Commit from any wallet (e.g. hardware wallets)\n\nLater:\n\n- [ ] Incremental de-\/commit and optimistic Head closure protocol extensions\n- [ ] Modular API via event streaming plugins\n- [ ] Automated handling of rollbacks\n- [ ] Relay-capable, mesh network\n- [ ] Multiple Heads per hydra-node, managed via API\n\nSee our [roadmap](https:\/\/github.com\/orgs\/input-output-hk\/projects\/21\/views\/7) for more details.\n\n## :handshake: Contributing\n\nThe best way to contribute is to provide feedback. Give the [demo](.\/demo) a spin and have a look at our [documentation](https:\/\/hydra.family\/head-protocol).\nShould you have any questions, ideas or issues, we would like to hear from you:\n\n- #ask-hydra on the IOG [Discord server](https:\/\/discord.gg\/Qq5vNTg9PT)\n- create a Github [Discussion](https:\/\/github.com\/cardano-scaling\/hydra\/discussions)\n- open a Github [Issue](https:\/\/github.com\/cardano-scaling\/hydra\/issues\/new)\n\nPlease follow our [Contributing Guidelines](.\/CONTRIBUTING.md) and [Code of Conduct](.\/CODE-OF-CONDUCT.md).\n\n## üôè Credits\n\n- Logo created by Alexander Wende\n\n---\n\n<p align=\"center\">\nThanks for visiting and enjoy :heart:!\n<\/p>"
  },{
    "name": "contract",
    "scope": "githoney",
    "repository_url": "https://github.com/githoney-io/githoney-smart-contract",
    "blueprint_url": "https://github.com/githoney-io/githoney-smart-contract/blob/main/onchain/plutus.json",
    "published_date": 1727787600,
    "readme": "# Githoney\n\nGitHoney is a smart contract implementation designed to facilitate bounty creation, reward distribution, and other associated transactions on the blockchain. This repository contains the onchain Aiken code and offchain TypeScript code for transaction building and querying.\n\n## Environment Variables\n\nEnsure you have a `.env` file in the `githoney\/offchain` directory with the following variables:\n\n```js\nCREATION_FEE = ...\nREWARD_FEE = ...\nGITHONEY_ADDRESS = ...\n```\n\nWhere `CREATION_FEE` must be a number greater than 2,000,000 (MIN ADA), representing the fee in lovelaces to create a bounty. And `REWARD_FEE` must be a number between 0 and 10,000, representing the percentage of the reward that will be paid.\n\n## Setup\n\nFollow these steps to set up the project for the first time:\n\n1. Navigate to the `githoney\/offchain` directory and install all dependencies:\n\n   ```sh\n   npm install\n   ```\n\n2. Build the code and produce an `offchain-1.0.0.tgz` file by running:\n\n   ```sh\n   npm pack\n   ```\n\n3. In another npm project, install the library as a local npm package:\n\n   ```sh\n   npm i \/path\/to\/offchain-1.0.0.tgz\n   ```\n\n## Running Tests\n\nTo run the tests, add additional variables to the `.env` file:\n\n```js\nBLOCKFROST_PROJECT_ID = preprodMySecretBlockFrostProjectId\nMAINTAINER_SEED = ...\nCONTRIBUTOR_SEED = ...\nGITHONEY_SEED = ...\n```\n\nWhere the `preprodMySecretBlockFrostProjectId` can be generated by following this [tutorial](https:\/\/blockfrost.dev\/docs\/overview\/getting-started).\n\nRun all tests together using the following command:\n\n```sh\nnpm run test\n```\n\n### Running Individual Tests\n\nTo run individual tests, use the following command format:\n\n```sh\nnpm run <test-name>\n```\n\nReplace `<test-name>` with one of the following options:\n\n- test-create\n- test-addrewards\n- test-assign\n- test-merge\n- test-close\n- test-claim\n\n# Offchain Library API\n\n## Bounties Operations\n\n### Create BountyUtxo\n\nThis transaction creates a `BountyUtxo` locking the reward assets plus min ADA and a `BountyIdToken`. It sets the maintainer, deadline, admin, and merged (**set to False**) in the datum.\n\n```typescript\n\/**\n * Builds a `createBounty` transaction. The tx is built in the context of the maintainer wallet.\n * @param settingsUtxo The settings UTxO.\n * @param maintainerAddr The maintainer's address.\n * @param adminAddr The admin's address.\n * @param rewards The reward assets and amount to be locked in the bounty UTxO.\n * @param deadline The deadline for the bounty.\n * @param bounty_id The bounty identifier.\n * @param lucid Lucid instance.\n * @returns The cbor of the unsigned transaction.\n *\/\nasync function createBounty(\n  settingsUtxo: UTxO,\n  maintainerAddr: string,\n  adminAddr: string,\n  rewards: Assets,\n  deadline: bigint,\n  bounty_id: string,\n  lucid: Lucid\n): Promise<string>;\n```\n\n### Add Reward\n\nAdds additional reward assets to an existing `BountyUtxo`.\n\n```typescript\n\/**\n * Builds an `addReward` transaction. The tx is built in the context of any wallet.\n * @param settingsUtxo The settings UTxO.\n * @param utxoRef The reference of the last transaction output that contains the bounty UTxO.\n * @param address The address of the current wallet.\n * @param rewards The reward assets and amount to be added.\n * @param lucid Lucid instance.\n * @returns The cbor of the unsigned transaction.\n *\/\nasync function addRewards(\n  settingsUtxo: UTxO,\n  utxoRef: OutRef,\n  address: string,\n  rewards: Assets,\n  lucid: Lucid\n): Promise<string>;\n```\n\n### Assign Contributor\n\nSets the contributor's `Wallet` to the `BountyUtxo` datum and adds the contributor's min ADA to the value.\n\n```typescript\n\/**\n * Builds an `assignContributor` transaction. The tx is built in the context of the contributor wallet.\n * @param settingsUtxo The settings UTxO.\n * @param utxoRef The reference of the last transaction output that contains the bounty UTxO.\n * @param contributorAddr The contributor's address.\n * @param lucid Lucid instance.\n * @returns The cbor of the unsigned transaction.\n *\/\nasync function assignContributor(\n  settingsUtxo: UTxO,\n  utxoRef: OutRef,\n  contributorAddr: string,\n  lucid: Lucid\n): Promise<string>;\n```\n\n### Close Bounty\n\nThe admin closes the bounty, returning the reward assets to the maintainer and burning the `BountyIdToken`. If a contributor is assigned, the min ADA is returned to them.\n\n```typescript\n\/**\n * Builds a `closeBounty` transaction. The tx is built in the context of the admin wallet.\n * @param settingsUtxo The settings UTxO.\n * @param lucid Lucid instance.\n * @param utxoRef The reference of the last transaction output that contains the bounty UTxO.\n * @returns The cbor of the unsigned transaction.\n *\/\nasync function closeBounty(\n  settingsUtxo: UTxO,\n  utxoRef: OutRef,\n  lucid: Lucid\n): Promise<string>;\n```\n\n### Merge Bounty\n\nPays GitHoney the reward assets multiplied by the `BountyRewardFee`. Updates the merged field to _True_. The contributor's min ADAs remain in the UTxO.\n\n```typescript\n\/**\n * Builds a `mergeBounty` transaction. The tx is built in the context of the admin wallet.\n * @param settingsUtxo The settings UTxO.\n * @param utxoRef The reference of the last transaction output that contains the bounty UTxO.\n * @param lucid Lucid instance.\n * @returns The cbor of the unsigned transaction.\n *\/\nasync function mergeBounty(\n  settingsUtxo: UTxO,\n  utxoRef: OutRef,\n  lucid: Lucid\n): Promise<string>;\n```\n\n### Claim Bounty\n\nPays the contributor the remaining reward assets and burns the `BountyIdToken`.\n\n```typescript\n\/**\n * Builds a `claimBounty` transaction. The tx is built in the context of the contributor wallet.\n * @param settingsUtxo The settings UTxO.\n * @param utxoRef The reference of the last transaction output that contains the bounty UTxO.\n * @param lucid Lucid instance.\n * @param contributorAdrr The contributor's address.\n * @returns The cbor of the unsigned transaction.\n *\/\nasync function claimBounty(\n  settingsUtxo: UTxO,\n  utxoRef: OutRef,\n  lucid: Lucid,\n  contributorAddr: string\n): Promise<string>;\n```\n\n## Settings Operations\n\n### Deploy Settings\n\nThis transaction deploys the `GlobalSettings` UTxO, which holds the global parameters of the dApp. The NFT policy ID of the minted token identifies the `GlobalSettings` UTxO. Besides the settings, the utxo will hold also the `Githoney Validator` code, due to this utxo will be used as reference input of all the redeemers of the `Githoney Validator`.\n\n```typescript\n\/**\n * Builds a `deploy` transaction. The tx is built in the context of the GitHoney address. This transaction configures the global parameters of the dApp, including the creation fee, reward fee, and the GitHoney wallet. These parameters are obtained from the environment configuration.\n * @param lucid Lucid instance.\n * @returns The cbor of the unsigned transaction and a output reference from the asoociated wallet.\n *\/\nasync function deploySettings(\n  lucid: Lucid\n): Promise<{ cbor: string; outRef: OutRef }>;\n```\n\n### Update Settings\n\nUpdates the global parameters of the dApp, changing the datum of the `GlobalSettings` UTxO.\n\n```typescript\n\/**\n * Builds an `update` transaction. The tx is built in the context of the GitHoney address.\n * @param settingsUtxo The settings UTxO.\n * @param lucid Lucid instance.\n * @param settings The new settings to be updated (Optional).\n * @returns The cbor of the unsigned transaction.\n *\/\nasync function updateSettings(\n  settingsUtxo: UTxO,\n  lucid: Lucid,\n  settings?: {\n    githoneyWallet: {\n      paymentKey: string;\n      stakeKey: string | null;\n    };\n    creationFee: bigint;\n    rewardFee: bigint;\n  }\n): Promise<string>;\n```\n\n### Close Settings\n\nCloses the `GlobalSettings` UTxO, burning the NFT and refunding the ADA locked to githoney.\n\n```typescript\n\/**\n * Builds a `closeSettings` transaction. The tx is built in the context of the GitHoney address.\n * @param utxoRef The output reference passed as parameter of the settings nft minting policy,\n * this outRef is returned in the deploySettings operation.\n * @param settingsUtxo The settings UTxO.\n * @param lucid Lucid instance.\n * @returns The cbor of the unsigned transaction.\n *\/\n\nasync function closeSettings(\n  utxoRef: OutRef,\n  settingsUtxo: UTxO,\n  lucid: Lucid\n): Promise<string>;\n```"
  },{
    "name": "sell_nft",
    "scope": "ctf",
    "repository_url": "https://github.com/vacuumlabs/cardano-ctf",
    "blueprint_url": "https://github.com/vacuumlabs/cardano-ctf/blob/main/01_sell_nft/plutus.json",
    "published_date": 1727787600,
    "readme": "# sell_nft\n\nIn this task, we will explore a simple peer to peer NFT marketplace. The\nvalidator is a simple contract where the seller locks an NFT. The datum contains\nthe address of the seller and the price of the NFT he wants to sell for. Anyone\ncan then buy this NFT by spending the UTxO in a transaction given he sends the\nprice of the NFT to the seller.\n\nDuring the setup, two UTxOs are created at that script address. They both\ncontain a different NTF, belong to the same owner and have different price. Your\ngoal is to acquire both of them without spending too much ADA.\n\n## On-chain code\n\nThe important validator here is the [nft_sell.ak](.\/validators\/nft_sell.ak).\nThat is the smart contract that governs the selling and buying of the NFTs.\n\nThe other two files are helpers that you do not need to use, but feel free to\nexplore:\n\n- [locked.ak](.\/validators\/locked.ak) ‚Äî A validator where anything gets locked.\n  Forever. The address of this validator is used as the seller of the NFTs.\n- [nft.ak](.\/validators\/nft.ak) ‚Äî The minting policy of the NFTs. It checks that\n  given UTxOs are spent, thus guaranteeing that the minted NFTs are not reminted\n  in future transactions.\n\n## Off-chain code\n\nYou only have to make changes in the `player.ts` file. Similar to the previous\nlevel, you can create it by copying the\n[player_template.ts](.\/scripts\/player_template.ts). Inside the file, the\nrelevant parts are clearly commented, starting with\n`================ YOUR CODE STARTS HERE` and ending with\n`================ YOUR CODE ENDS HERE`.\n\nYou should interact with the deployed smart contracts in between the two\ncomments. The code that is already there buys a single NFT from the seller ‚Äî it\ndoesn't pass all the tests because it buys only one of the two required NFTs.\nTry to pass all the tests by modifying it.\n\nAs before, you can run the code and tests with:\n`deno run --allow-net --allow-read .\/scripts\/run.ts`"
  },{
    "name": "vesting",
    "scope": "ctf",
    "repository_url": "https://github.com/vacuumlabs/cardano-ctf",
    "blueprint_url": "https://github.com/vacuumlabs/cardano-ctf/blob/main/02_vesting/plutus.json",
    "published_date": 1727787600,
    "readme": "# vesting\n\nIn this level, you are presented with a straightforward vesting smart contract.\nThe contract locks a certain amount of ADA assets, allowing the beneficiary to\nclaim them in full once the specified vesting period expires. In our example,\nthe vesting period is set to 5 hours. However, waiting for it is boring. Your\ntask is to uncover the concealed vulnerability in the smart contract and unlock\nthe funds much sooner.\n\nThe setup involves creating a vesting UTxO that secures an ADA amount for a\n5-hour period, with you as the sole beneficiary.\n\n## On-chain code\n\nThere is a single validator in `vesting.ak`.\n\nNote the additional `?` after certain logical predicates in the code. These\nindicators assist in pinpointing where the validator fails. You can check the\ndocumentation\n[here](https:\/\/aiken-lang.org\/language-tour\/troubleshooting#-operator). To\ndisplay the stack trace of failed predicates, the validator needs to be compiled\nwith a corresponding flag which may depend on your Aiken version. The\n`--keep-traces` in older versions or `-t verbose` in newer ones. Check the\n`aiken build --help` for more information.\n\n## Off-chain code\n\nSimilar to the previous levels, you need to duplicate the `player_template.ts`\nfile, naming it `player.ts`, and executing the off-chain code with\n`deno run --allow-net --allow-read .\/scripts\/run.ts`.\n\n### Timestamps\n\nVesting operates with timestamps. However, the emulator used for testing\ncontains an own internal clock that does not correspond to the current time.\nThis creates a discrepancy between the code run on the emulator and on the\ntestnet, each requiring different timestamps. To address this issue, the\n`getCurrentTime(lucid)` function was introduced. This function returns the\ncurrent timestamp (in milliseconds) based on the used framework. You can then\nmanipulate this timestamp as usual.\n\nFor instance, the timestamp at the time of the vesting creation could be\n`getCurrentTime(lucid)` and the resulting vesting end would then be set to\n`getCurrentTime(lucid) + 5 * 60 * 60 * 1000`.\n\n### Transaction building\n\nTransactions in this level are somewhat more intricate, involving the setting of\nmultiple additional parameters to build the transactions. To understand the\nworkings of these options and explore other configurable parameters, refer to\nthe [documentation](https:\/\/deno.land\/x\/lucid@0.10.7\/mod.ts?s=Tx). While this\nlevel provides all the necessary information, understanding the full extent of\nyour options can prove valuable in later levels."
  },{
    "name": "multisig_treasury",
    "scope": "ctf",
    "repository_url": "https://github.com/vacuumlabs/cardano-ctf",
    "blueprint_url": "https://github.com/vacuumlabs/cardano-ctf/blob/main/03_multisig_treasury/plutus.json",
    "published_date": 1727787600,
    "readme": "# multisig_treasury\n\nThis level introduces a simple multi-signature treasury. The treasury holds a\ncertain amount of ADA and is owned by a group of addresses. To release any\nportion of the funds, all its owners must agree. To express their will, they\nsign a Multisig UTxO that specifies the amount to be released and the\ndestination address ‚Äì where the funds should be released. Most importantly, it\naccumulates signatures as they can sign it across multiple transactions.\n\nIn this task, a treasury UTxO is created, locking 10 ADA for two owners ‚Äì\nyourself and an another owner. To withdraw the funds, you must provide the\ntreasury validator with a multisig UTxO signed by both owners. However, you lack\nthe private key for the second address and can not contact him, making it\nseemingly impossible to obtain his signature. Can you find a way to bypass the\ncontract and release the funds?\n\n## On-chain code\n\nTwo validators are involved in this task:\n\n- `treasury`: Treasury UTxOs contain ADA, and their datum includes a set of\n  owners. Withdrawal from this UTxO is possible when a multisig UTxO, containing\n  signatures from all treasury owners, is provided.\n\n- `multisig`: Multisig UTxOs contain withdrawal proposals in their datum. A\n  proposal specifies the amount, beneficiary, and a set of addresses that need\n  to sign it. This UTxO collects signatures one by one, allowing any specified\n  address to add its signature in the appropriate transaction.\n\nNote that the treasury validator is parameterized with a hash of the multisig\nvalidator, ensuring that only the corresponding multisig script can unlock the\ngiven treasury.\n\nIn addition to the validators, `lib\/types.ak` contains the datum and the\nredeemer specifications for both validators. There is also the `lib\/utils.ak`\nutils file containing some of the common parser logic to not polute the checks.\n\n## Off-chain code\n\nAs usual, create a copy of the `player_template.ts` named `player.ts` that you\ncan run with the `deno run --allow-net --allow-read .\/scripts\/run.ts` command.\nThe code that requires modification lies in this file in the appropriate\nsection.\n\nWe recommend examining the rest of the off-chain code, especially the `setup()`\nfunction, which can aid in understanding the setup of this level and provide\nuseful examples of how to interact with the validators. This approach is also\nrecommended for later levels."
  },{
    "name": "tipjar",
    "scope": "ctf",
    "repository_url": "https://github.com/vacuumlabs/cardano-ctf",
    "blueprint_url": "https://github.com/vacuumlabs/cardano-ctf/blob/main/04_tipjar/plutus.json",
    "published_date": 1727787600,
    "readme": "# tipjar\n\nWe created a Tip Jar where you can send us tips with nice messages attached! You\ncan use it to show how much you appreciate the CTF. The Jar works very simply ‚Äì\nanyone can put (testnet) ADA into it and write a new message into the datum. We\nenforce a minimum tip to prevent attackers from increasing contention of the Tip\nJar by adding too little ADA. The owner can empty the Tip Jar anytime.\n\nYour goal in this task is different from the previous tasks ‚Äì you want to just\n**damage** the owner and **forbid other people from tipping** into the Jar. Such\nattacks are called Denial Of Service (DoS). The tests in this task will try to\nadd one more tip, and if they fail, you win!\n\n## Warnings\n\nBe careful, some solutions might pass in the emulator but not on the testnet.\nAlso, because of the nature of this task, there are possibly more paths to the\nsolution. Please drop us a comment if you think you found a unique solution!"
  },{
    "name": "purchase_offer",
    "scope": "ctf",
    "repository_url": "https://github.com/vacuumlabs/cardano-ctf",
    "blueprint_url": "https://github.com/vacuumlabs/cardano-ctf/blob/main/05_purchase_offer/plutus.json",
    "published_date": 1727787600,
    "readme": "# purchase_offer\n\nThis level concerns a peer to peer NFT marketplace with an advanced feature ‚Äî\npurchase offers. A buyer is able to create a purchase offer where she puts the\nADA amount she offers in exchange for an asset she wants to purchase. She\nspecifies the asset in the datum. Moreover, she can choose to ask for any NFT\nfrom a particular collection.\n\nDuring the setup, a unique precious NFT is minted and put into your wallet. In\nthe same transaction, multiple purchase offers are created. Since you own an NFT\nsomebody is asking for in their purchase offers, you can sell it to them and\nunlock their ADA. Can you unlock more than they offer?\n\n## On-chain code\n\nThere is a single validator and a single minting policy that are involved in\nthis task:\n\n- `nft`: It is a simple minting policy by which your unique precious NFT is\n  minted. It is the same policy used in the [sell_nft](..\/01_sell_nft\/) task.\n\n- `purchase_offer`: Purchase offer validator. The amount of ADA locked in\n  purchase offer UTxOs is fully unlocked if the desired NFT is sold in the\n  transaction. The sold NFT is checked against the configuration in the datum.\n  The datum carries the desired policy id and an optional token name of the\n  asset. If no token name is set, any NFT from the collection is accepted. The\n  redeemer specifies the specific asset that is being sold.\n\n## Off-chain code\n\nAs usual, create a copy of the `player_template.ts` named `player.ts` that you\ncan run with the `deno run --allow-net --allow-read .\/scripts\/run.ts` command.\nThe code that requires modification lies in this file in the appropriate\nsection.\n\nAs always, we recommend examining the rest of the off-chain code, especially the\n`setup()` function in [task.ts](.\/scripts\/task.ts) which can aid in\nunderstanding the setup of this level and provide useful examples of how to\ninteract with the validators."
  },{
    "name": "tipjar_v2",
    "scope": "ctf",
    "repository_url": "https://github.com/vacuumlabs/cardano-ctf",
    "blueprint_url": "https://github.com/vacuumlabs/cardano-ctf/blob/main/06_tipjar_v2/plutus.json",
    "published_date": 1727787600,
    "readme": "# tipjar_v2\n\n**Spoiler alert: Do not attempt this level before solving level 04 -\n[tipjar](..\/04_tipjar\/). This task builds on top of it and reveals the idea of\nthe vulnerability.**\n\nThe code and the goal of this level are both similar to the\n[tipjar](..\/04_tipjar\/). The validator is updated to mitigate two attack vectors\npresent in the previous version. However, we believe that it is still possible\nto perform a DoS attack on the Tip Jar and prevent other people from tipping.\nCan you find and demonstrate the vulnerability?\n\n## Warnings\n\nSome solutions might pass in the emulator but not on the testnet. Always verify\nyour solution on the testnet as well.\n\nIf your solution from the [tipjar](..\/04_tipjar\/) passes here as well, try to go\nback and find a different attack vector for the first version of the tipjar."
  },{
    "name": "multisig_treasury_v2",
    "scope": "ctf",
    "repository_url": "https://github.com/vacuumlabs/cardano-ctf",
    "blueprint_url": "https://github.com/vacuumlabs/cardano-ctf/blob/main/07_multisig_treasury_v2/plutus.json",
    "published_date": 1727787600,
    "readme": "# multisig_treasury_v2\n\n**Spoiler alert:** This level is a direct continuation of\n[Level 03: Multisig Treasury](..\/03_multisig_treasury\/) and contains spoilers\nfor its solution. We recommend solving this level only after successfully\ncompleting Level 03.\n\nThis level once again uses a simple multi-signature treasury. The treasury holds\na certain amount of ADA and is owned by a group of addresses. To release any\nportion of the funds, all its owners must agree. To express their will, they\nsign a Multisig UTxO that specifies the amount to be released and the\ndestination address ‚Äì where the funds should be released. Most importantly, it\naccumulates signatures as they can sign it across multiple transactions.\n\nTo add more protection to the smart contract, a validation token is introduced.\nFor the multisig UTxO to be accepted and funds be released, the validation token\nmust be present within the UTxO. The validation token can only be minted during\nthe creation of the multisig UTxO, and it validates its datum. To link the\nvalidation token with the multisig UTxO, the token's name must be equal to the\nvalidator hash of the multisig contract.\n\nThe statement is similar to the previous Multisig Treasury level. A treasury\nUTxO is created, locking 10 ADA for two owners ‚Äì yourself and an another owner.\nTo withdraw the funds, you must provide the treasury validator with a multisig\nUTxO signed by both owners. However, you lack the private key for the second\naddress and can not contact him, making it seemingly impossible to obtain his\nsignature. Can you find a way to bypass the contract and release the funds?\n\n## On-chain code\n\nTwo validators and one minting policy are involved in this task:\n\n- `treasury`: Treasury UTxOs contain ADA, and their datum includes a set of\n  owners. Withdrawal from this UTxO is possible when a multisig UTxO, containing\n  signatures from all treasury owners, is provided.\n\n- `multisig`: Multisig UTxOs contain withdrawal proposals in their datum. A\n  proposal specifies the amount, beneficiary, and a set of addresses that need\n  to sign it. This UTxO collects signatures one by one, allowing any specified\n  address to add its signature in the appropriate transaction. To be validated,\n  the UTxO must contain the proper validation token.\n\n- `validation_token`: Minting policy for the validation token. The token can\n  only be minted when a multisig UTxO with a correct datum is created, and the\n  token must be locked inside the UTxO.\n\nNote that the multisig validator is parameterized with the hash of the treasury\nvalidator, and the treasury contains the hash of the multisig validator in its\ndatum. This ensures that a multisig can only be used with a valid treasury and\nvice versa. The multisig validator is also parametrized with the policy id of\nthe validation token to ensure that it can only be spent if a valid validation\ntoken is present.\n\nIn addition to the validators, `lib\/types.ak` contains the datum and the\nredeemer specifications for both validators. There is also the `lib\/utils.ak`\nutils file containing some of the common parser logic to not polute the checks.\n\n## Off-chain code\n\nAs usual, create a copy of the `player_template.ts` named `player.ts` that you\ncan run with the `deno run --allow-net --allow-read .\/scripts\/run.ts` command.\nThe code that requires modification lies in this file in the appropriate\nsection."
  },{
    "name": "lending",
    "scope": "ctf",
    "repository_url": "https://github.com/vacuumlabs/cardano-ctf",
    "blueprint_url": "https://github.com/vacuumlabs/cardano-ctf/blob/main/08_lending/plutus.json",
    "published_date": 1727787600,
    "readme": "# lending\n\nIn this level, you'll analyze a straightforward peer-to-peer lending platform\nwhere borrowers request loans by creating UTxOs specifying the loan amount (only\nADA is supported) and locking collateral tokens to guarantee repayment. Anyone\ncan fulfill the loan, activating it by sending funds to the borrower. Each loan\nmust be repaid within the specified time frame, along with the specified\ninterest.\n\nUpon loan repayment, borrowers can unlock their collateral, and lenders can\nclaim the repaid ADA. If a loan remains unpaid within the set time frame,\nlenders can claim the locked collateral.\n\nTwo borrowers have requested multiple loans. Your task is to uncover a hidden\nvulnerability and acquire some ADA for yourself. Keep in mind three key\nassumptions:\n\n- Collateral tokens locked in lending UTxOs hold no real value for you; your\n  sole aim is to acquire ADA. Stealing collateral tokens won't lead to a\n  successful pass of the tests. Imagine that there's no market to exchange\n  those.\n- You seek to obtain more ADA than you started with. Merely gaining interest\n  from the loans won't suffice.\n- Locked collateral tokens are invaluable to the borrowers. They are certainly\n  worth more for them than the value borrowed. Even if they suspect foul play,\n  they'll proceed through the lending protocol to reclaim the collateral tokens.\n\n## On-chain code\n\nThe on-chain code comprises two files:\n\n- `lending`: This serves as the primary validator responsible for validating all\n  interactions involving lending UTxOs. Pay close attention to its datum as it's\n  rather intricate, requiring careful parameter configuration for the validator\n  to advance through various stages.\n\n- `collateral_token`: This file contains the minting policy for our collateral\n  tokens. It's utilized by the borrowers. To ensure uniqueness for each user,\n  tokens can only be minted if their asset name matches the hash of the user's\n  signature. In other words, you can't mint collateral tokens that are put as\n  collateral in someone else's loan request.\n\n## Off-chain code\n\nAs usual, create a copy of the `player_template.ts` named `player.ts` that you\ncan run with the `deno run --allow-net --allow-read .\/scripts\/run.ts` command.\nThe code that requires modification lies in this file in the appropriate\nsection.\n\nNote that the code necessitates interaction among different users. The\n`GameData` includes wallets for other users, along with their private keys. **Do\nnot use these private keys** while solving the level. It is not needed. The only\nexception is the `askForRepayment` function, which simulates a borrower seeking\nto unlock their collateral tokens. When provided with the correct collateral\ntoken within the lending UTxO, they will repay it in full. Utilize this function\nsolely to repay the UTxOs created during the setup. Do not exploit any\nvulnerability found within this function. Find a smart contract vulnerability\ninstead.\n\nSee the `player_template.ts` for an example of a single interaction between a\nborrower and a lender."
  },{
    "name": "multisig_treasury_v3",
    "scope": "ctf",
    "repository_url": "https://github.com/vacuumlabs/cardano-ctf",
    "blueprint_url": "https://github.com/vacuumlabs/cardano-ctf/blob/main/09_multisig_treasury_v3/plutus.json",
    "published_date": 1727787600,
    "readme": "# multisig_treasury_v3\n\n**Spoiler alert:** This level is a direct continuation of\n[Level 07: Multisig Treasury v2](..\/07_multisig_treasury_v2\/) and contains\nspoilers for its solution. We recommend solving this level only after\nsuccessfully completing Level 07.\n\nThis level again uses a simple multi-signature treasury. The treasury holds a\ncertain amount of ADA and is owned by a group of addresses. To release any\nportion of the funds, all its owners must agree. To express their will, they\nsign a Multisig UTxO that specifies the amount to be released and the\ndestination address ‚Äì where the funds should be released. Most importantly, it\naccumulates signatures as they can sign it across multiple transactions.\n\nThe statement is the same as in the previous Multisig Treasury level. A treasury\nUTxO is created, locking 10 ADA for two owners ‚Äì yourself and an another owner.\nTo withdraw the funds, you must provide the treasury validator with a multisig\nUTxO signed by both owners. However, you lack the private key for the second\naddress and can not contact him, making it seemingly impossible to obtain his\nsignature.\n\n## Changes\n\n**The multisig UTxO validator has been modified** to mitigate a specific attack\nvector that could be exploited in Level 07.\n\n‚ö†Ô∏è However, it's important to note that the remaining attack vector was also\npresent in the Level 07's validator. If you successfully exploited it in the\nprevious level, congratulations! You can find out whether that's the case by\ntrying to run your `player.ts` from the Level 07 in this task. If it passes this\nlevel, we encourage you to return to Level 07 and try to solve it differently\n**without** reading the codebase of this level.\n\nThe on-chain code in this level is the same as in the previous level except for\nthe vulnerability from the Level 07 that is fixed. The off-chain code of this\ntask is exactly the same as before. You can refer to their high-level\ndescriptions\n[in the previous README](..\/07_multisig_treasury_v2\/README.md#on-chain-code)."
  },{
    "name": "king_of_cardano",
    "scope": "ctf",
    "repository_url": "https://github.com/vacuumlabs/cardano-ctf",
    "blueprint_url": "https://github.com/vacuumlabs/cardano-ctf/blob/main/10_king_of_cardano/plutus.json",
    "published_date": 1727787600,
    "readme": "# king_of_cardano\n\nThe King of Cardano is a competition, where the winner gets the opportunity to\nmint his own customized King of Cardano NFT! The rules of the competition are\nsimple ‚Äî you have to spend more money than your predecessor to overthrow him as\na king. The overthrown king gets all his money back. Whoever is the king once\nthe competition is over is the real king and can mint his NFT.\n\n## On-chain code\n\nThere is a single validator and two minting policies that are involved in this\ntask:\n\n- `king_nft`: The price for the winner. The actual King of Cardano NFT. It can\n  be minted only once and by the current king once the competition is over.\n\n- `king_of_cardano`: The main contract. It allows for three actions:\n  - **OverthrowKing**: Enables you to overthrow the current king and become one.\n  - **CloseCompetition**: The admin uses it to end the competition.\n  - **MintKingNFT**: Once the competition is closed, the final king can use it\n    to mint the NFT.\n\n- `unique_nft`: This is a similar policy used in other tasks as well, for the\n  purpose of minting a unique NFT that can not be minted again. It is modified\n  to allow burning of the token. In this task, it is used in the bootstrapping\n  process: The person that initializes the competition first mints the unique\n  NFT using this policy, then compiles all the other scripts using this NFT as a\n  parameter and puts the NFT itself into the newly created `king_of_cardano`\n  UTxO. In a way, it also serves as a validity token for that UTxO, uniquely\n  identifying the correct competition UTxO.\n\n## Off-chain code\n\nAs usual, create a copy of the `player_template.ts` named `player.ts` that you\ncan run with the `deno run --allow-net --allow-read .\/scripts\/run.ts` command.\n\nThe testing process in this task is as follows:\n\n1. We try to overthrow the current king. You pay for the fees, so you should\n   leave enough ADA in your wallet so that the transaction is feasible. We check\n   that you do. The attempt should fail.\n2. The admin closes the competition. This is a simplification to simulate an\n   accelerated passage of time. Under normal circumstances, no administrative\n   role would be required. This adjustment is made purely for simplification\n   purposes.\n3. We try to claim the King of Cardano NFT on your behalf.\n\nYour aim is to become a king who can not be overthrown and who ultimately claims\na customized King of Cardano NFT. Don't forget to pick a cool nickname :).\n\n## Notes\n\nThis task points to a number of problems and is language specific. There are at\nleast two distinct attack vectors with the stack we chose. The upcoming blogpost\ndiscussing this will discuss three problems this points to. Ultimately, there is\nat least one issue that is an issue in all the common languages ‚Äî Plutus,\nPlutarch, Aiken. Try to find it. Good luck and have fun!"
  }]
}