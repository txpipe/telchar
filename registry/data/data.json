{
  "dapps": [{
    "name": "asteria",
    "scope": "txpipe",
    "repository_url": "https://github.com/txpipe/asteria",
    "blueprint_url": "https://github.com/txpipe/asteria/blob/main/onchain/src/plutus.json",
    "published_date": 1727787600,
    "readme": "# Asteria\n\nA Cardano bot challenge to showcase the capabilities of the eUTxO model.\n\n## Mechanics\n\nIn this bot challenge you compete by moving a ship (your bot) through a 2D grid. The ship that reaches the center is allowed to collect the rewards.\n\nShips are implemented as UTxOs with a datum holding a pair of (x, y) coordinates that represent their position in the 2D grid. To move a ship, a transaction must consume the UTxO and create a new one with holding the new position.\n\n![grid](https:\/\/github.com\/txpipe\/asteria\/assets\/653886\/d5d35b42-b554-4eaa-a798-84fe7b0b9787)\n\nMovement of the ships is constrained by a _Space-Time_ on-chain script that limits their velocity. Strictly speaking, the max distance that a ship can move in any given transaction has a constant upper bound. Distances are defined using [Manhattan distance] to simplify the math.\n\n![move tx](https:\/\/github.com\/txpipe\/asteria\/assets\/653886\/ddcbc786-8947-4c0a-b0bc-4cd7de1bcd0f)\n\nMovement of the ships is also constrained by a _fuel_ token that is required for any change in position. An specifc amount of _fuel_ is required per distance unit. The lack of the required fuel amount will block the movement of the ship.\n\n![gather tx](https:\/\/github.com\/txpipe\/asteria\/assets\/653886\/5c3af5bc-5aad-4598-b35e-90e0729e82df)\n\nTo accumulate fuel, ships must _gather_ these tokens which are distributed randomly across the same grid. To gather a fuel token, your ship needs to be in the same coordinates as the fuel.\n\nTo create a ship, a participant must mint the corresponding NFT from the valid policy id. A minimum amount of ADA will be requried for the mint. This ADA used to mint the ships will be increment the rewards locked for the winner. The initial position of the ship is decided by the player but is contrainted to the external boundary of the grid.\n\nA unique UTxO will be place at the center of the grid to hold the rewards for the winner of the challenge. To claim rewards, a ship must be located at the center of the grid. Each claim is allowed to collect 1\/2 of the total rewards.\n\n## Backstory\n\n\/\/ TODO\n\n## Getting started\n\n\/\/ TODO\n\n## Monitoring progress\n\nWe have a basic visual 2D map that allows you to show the position of all the ships and fuel in real-time (updated at each block). We encourage developers to create their own visualizers, we'll showcase any project in the homepage of the challenge."
  },{
    "name": "hello_world",
    "scope": "ctf",
    "repository_url": "https://github.com/vacuumlabs/cardano-ctf",
    "blueprint_url": "https://github.com/vacuumlabs/cardano-ctf/blob/main/00_hello_world/plutus.json",
    "published_date": 1727787600,
    "readme": "# hello_world\n\nSo, you managed to install everything and now are eager to try your hands on the\nreal stuff. You are in the right place!\n\nThe validator in this task simply locks given ADA and you have to provide the\ncorrect password to unlock it. However, something is wrong and the unlocking of\nthe funds fails with an error:\n\n```\nerror: Uncaught (in promise) \"Redeemer (Spend, 0): The provided Plutus code called 'error'.\\n\\nExBudget {\\n    mem: 21485,\\n    cpu: 8262844,\\n}\\n\\n\"\n```\n\nThis error means that the validator does not validate your transaction. Can you\nfind out why and unlock the funds?\n\n## How to solve the challenges\n\nEach challenge consists of 2 files that you should interact with:\n\n- The validator, located in\n  [validators\/hello_world.ak](.\/validators\/hello_world.ak)\n- The off-chain code, located in\n  [scripts\/player_template.ts](.\/scripts\/player_template.ts)\n\nThe validator code is read only — you are not supposed to modify it, you are\nsupposed to exploit it. The off-chain is divided into 3 parts:\n\n1. Setup — this part setups the vulnerable scenario. This means deploying the\n   smart contracts, minting NFTs if needed, ... You should not make changes to\n   this part of the file. Setup is done by calling the `setup` function from\n   [task.ts](.\/scripts\/task.ts).\n2. Interaction part — this is the only part that you need to edit. All your\n   exploits should go here. Usually, this part already includes an example\n   interaction which can get you going faster but is not sufficient just yet.\n   This code interacts with the smart contract in some way, but does not exploit\n   the vulnerability. This part is located in the\n   [player_template.ts](.\/scripts\/player_template.ts) file. To play, we\n   recommend keeping the template as is and **copying it** into a file called\n   `player.ts` which you can then freely edit.\n3. Tests — the tests verify whether you correctly achieved your goal. Tests are\n   done by calling the `test` function from the [task.ts](.\/scripts\/task.ts). Do\n   not modify this part.\n\n   Note: It may be possible to satisfy the tests by not exploiting the contract\n   the way it was intended to. Especially later in the more complex scenarios,\n   there may be multiple paths to achieve the same goal. If you think you came\n   up with a unique attack, [drop us a line](..\/README.md#feedback). We would\n   love to hear about that!\n\nThe above parts communicate through a structure called `GameData`. It is created\nduring the setup, and it contains everything you need for solving the challenges\nand everything that the tests require. You should not modify it. The tests may\nrequire additional info contained within a `TestData` structure. You will be\nspecifically instructed on how to modify it if needed. It is not needed for this\ntask.\n\nTo start, you can compile the validators by running `aiken build` in the root of\nthe task. Then you can run the sample code by running\n`deno run --allow-net --allow-read .\/scripts\/run.ts`. Run is our wrapper that\ncalls the function `play` from `player.ts` (if you did not copy\n`player_template.ts`, it will not work).\n\nThe wrapper first tests your code in the Lucid emulator. If all the tests inside\nthe emulator pass, the code is tested one more time against the testnet. The\nemulator provides early feedback so that you do not need to wait for all the\ntransactions being validated and accepted on the actual blockchain. Once you\nsolve the task, though, only the testnet offers a real-world environment and so\nit is really important to pass there as well. This default behavior can be\nchanged in the `common\/offchain\/config.ts`.\n\nThe goal of each task is to pass all the tests by editing the editable parts of\noff-chain code. You will get a _green_ congrats message once you get there.\n\nWith all that said, good luck and have fun!"
  },{
    "name": "sell_nft",
    "scope": "ctf",
    "repository_url": "https://github.com/vacuumlabs/cardano-ctf",
    "blueprint_url": "https://github.com/vacuumlabs/cardano-ctf/blob/main/01_sell_nft/plutus.json",
    "published_date": 1727787600,
    "readme": "# sell_nft\n\nIn this task, we will explore a simple peer to peer NFT marketplace. The\nvalidator is a simple contract where the seller locks an NFT. The datum contains\nthe address of the seller and the price of the NFT he wants to sell for. Anyone\ncan then buy this NFT by spending the UTxO in a transaction given he sends the\nprice of the NFT to the seller.\n\nDuring the setup, two UTxOs are created at that script address. They both\ncontain a different NTF, belong to the same owner and have different price. Your\ngoal is to acquire both of them without spending too much ADA.\n\n## On-chain code\n\nThe important validator here is the [nft_sell.ak](.\/validators\/nft_sell.ak).\nThat is the smart contract that governs the selling and buying of the NFTs.\n\nThe other two files are helpers that you do not need to use, but feel free to\nexplore:\n\n- [locked.ak](.\/validators\/locked.ak) — A validator where anything gets locked.\n  Forever. The address of this validator is used as the seller of the NFTs.\n- [nft.ak](.\/validators\/nft.ak) — The minting policy of the NFTs. It checks that\n  given UTxOs are spent, thus guaranteeing that the minted NFTs are not reminted\n  in future transactions.\n\n## Off-chain code\n\nYou only have to make changes in the `player.ts` file. Similar to the previous\nlevel, you can create it by copying the\n[player_template.ts](.\/scripts\/player_template.ts). Inside the file, the\nrelevant parts are clearly commented, starting with\n`================ YOUR CODE STARTS HERE` and ending with\n`================ YOUR CODE ENDS HERE`.\n\nYou should interact with the deployed smart contracts in between the two\ncomments. The code that is already there buys a single NFT from the seller — it\ndoesn't pass all the tests because it buys only one of the two required NFTs.\nTry to pass all the tests by modifying it.\n\nAs before, you can run the code and tests with:\n`deno run --allow-net --allow-read .\/scripts\/run.ts`"
  },{
    "name": "vesting",
    "scope": "ctf",
    "repository_url": "https://github.com/vacuumlabs/cardano-ctf",
    "blueprint_url": "https://github.com/vacuumlabs/cardano-ctf/blob/main/02_vesting/plutus.json",
    "published_date": 1727787600,
    "readme": "# vesting\n\nIn this level, you are presented with a straightforward vesting smart contract.\nThe contract locks a certain amount of ADA assets, allowing the beneficiary to\nclaim them in full once the specified vesting period expires. In our example,\nthe vesting period is set to 5 hours. However, waiting for it is boring. Your\ntask is to uncover the concealed vulnerability in the smart contract and unlock\nthe funds much sooner.\n\nThe setup involves creating a vesting UTxO that secures an ADA amount for a\n5-hour period, with you as the sole beneficiary.\n\n## On-chain code\n\nThere is a single validator in `vesting.ak`.\n\nNote the additional `?` after certain logical predicates in the code. These\nindicators assist in pinpointing where the validator fails. You can check the\ndocumentation\n[here](https:\/\/aiken-lang.org\/language-tour\/troubleshooting#-operator). To\ndisplay the stack trace of failed predicates, the validator needs to be compiled\nwith a corresponding flag which may depend on your Aiken version. The\n`--keep-traces` in older versions or `-t verbose` in newer ones. Check the\n`aiken build --help` for more information.\n\n## Off-chain code\n\nSimilar to the previous levels, you need to duplicate the `player_template.ts`\nfile, naming it `player.ts`, and executing the off-chain code with\n`deno run --allow-net --allow-read .\/scripts\/run.ts`.\n\n### Timestamps\n\nVesting operates with timestamps. However, the emulator used for testing\ncontains an own internal clock that does not correspond to the current time.\nThis creates a discrepancy between the code run on the emulator and on the\ntestnet, each requiring different timestamps. To address this issue, the\n`getCurrentTime(lucid)` function was introduced. This function returns the\ncurrent timestamp (in milliseconds) based on the used framework. You can then\nmanipulate this timestamp as usual.\n\nFor instance, the timestamp at the time of the vesting creation could be\n`getCurrentTime(lucid)` and the resulting vesting end would then be set to\n`getCurrentTime(lucid) + 5 * 60 * 60 * 1000`.\n\n### Transaction building\n\nTransactions in this level are somewhat more intricate, involving the setting of\nmultiple additional parameters to build the transactions. To understand the\nworkings of these options and explore other configurable parameters, refer to\nthe [documentation](https:\/\/deno.land\/x\/lucid@0.10.7\/mod.ts?s=Tx). While this\nlevel provides all the necessary information, understanding the full extent of\nyour options can prove valuable in later levels."
  },{
    "name": "multisig_treasury",
    "scope": "ctf",
    "repository_url": "https://github.com/vacuumlabs/cardano-ctf",
    "blueprint_url": "https://github.com/vacuumlabs/cardano-ctf/blob/main/03_multisig_treasury/plutus.json",
    "published_date": 1727787600,
    "readme": "# multisig_treasury\n\nThis level introduces a simple multi-signature treasury. The treasury holds a\ncertain amount of ADA and is owned by a group of addresses. To release any\nportion of the funds, all its owners must agree. To express their will, they\nsign a Multisig UTxO that specifies the amount to be released and the\ndestination address – where the funds should be released. Most importantly, it\naccumulates signatures as they can sign it across multiple transactions.\n\nIn this task, a treasury UTxO is created, locking 10 ADA for two owners –\nyourself and an another owner. To withdraw the funds, you must provide the\ntreasury validator with a multisig UTxO signed by both owners. However, you lack\nthe private key for the second address and can not contact him, making it\nseemingly impossible to obtain his signature. Can you find a way to bypass the\ncontract and release the funds?\n\n## On-chain code\n\nTwo validators are involved in this task:\n\n- `treasury`: Treasury UTxOs contain ADA, and their datum includes a set of\n  owners. Withdrawal from this UTxO is possible when a multisig UTxO, containing\n  signatures from all treasury owners, is provided.\n\n- `multisig`: Multisig UTxOs contain withdrawal proposals in their datum. A\n  proposal specifies the amount, beneficiary, and a set of addresses that need\n  to sign it. This UTxO collects signatures one by one, allowing any specified\n  address to add its signature in the appropriate transaction.\n\nNote that the treasury validator is parameterized with a hash of the multisig\nvalidator, ensuring that only the corresponding multisig script can unlock the\ngiven treasury.\n\nIn addition to the validators, `lib\/types.ak` contains the datum and the\nredeemer specifications for both validators. There is also the `lib\/utils.ak`\nutils file containing some of the common parser logic to not polute the checks.\n\n## Off-chain code\n\nAs usual, create a copy of the `player_template.ts` named `player.ts` that you\ncan run with the `deno run --allow-net --allow-read .\/scripts\/run.ts` command.\nThe code that requires modification lies in this file in the appropriate\nsection.\n\nWe recommend examining the rest of the off-chain code, especially the `setup()`\nfunction, which can aid in understanding the setup of this level and provide\nuseful examples of how to interact with the validators. This approach is also\nrecommended for later levels."
  },{
    "name": "tipjar",
    "scope": "ctf",
    "repository_url": "https://github.com/vacuumlabs/cardano-ctf",
    "blueprint_url": "https://github.com/vacuumlabs/cardano-ctf/blob/main/04_tipjar/plutus.json",
    "published_date": 1727787600,
    "readme": "# tipjar\n\nWe created a Tip Jar where you can send us tips with nice messages attached! You\ncan use it to show how much you appreciate the CTF. The Jar works very simply –\nanyone can put (testnet) ADA into it and write a new message into the datum. We\nenforce a minimum tip to prevent attackers from increasing contention of the Tip\nJar by adding too little ADA. The owner can empty the Tip Jar anytime.\n\nYour goal in this task is different from the previous tasks – you want to just\n**damage** the owner and **forbid other people from tipping** into the Jar. Such\nattacks are called Denial Of Service (DoS). The tests in this task will try to\nadd one more tip, and if they fail, you win!\n\n## Warnings\n\nBe careful, some solutions might pass in the emulator but not on the testnet.\nAlso, because of the nature of this task, there are possibly more paths to the\nsolution. Please drop us a comment if you think you found a unique solution!"
  },{
    "name": "purchase_offer",
    "scope": "ctf",
    "repository_url": "https://github.com/vacuumlabs/cardano-ctf",
    "blueprint_url": "https://github.com/vacuumlabs/cardano-ctf/blob/main/05_purchase_offer/plutus.json",
    "published_date": 1727787600,
    "readme": "# purchase_offer\n\nThis level concerns a peer to peer NFT marketplace with an advanced feature —\npurchase offers. A buyer is able to create a purchase offer where she puts the\nADA amount she offers in exchange for an asset she wants to purchase. She\nspecifies the asset in the datum. Moreover, she can choose to ask for any NFT\nfrom a particular collection.\n\nDuring the setup, a unique precious NFT is minted and put into your wallet. In\nthe same transaction, multiple purchase offers are created. Since you own an NFT\nsomebody is asking for in their purchase offers, you can sell it to them and\nunlock their ADA. Can you unlock more than they offer?\n\n## On-chain code\n\nThere is a single validator and a single minting policy that are involved in\nthis task:\n\n- `nft`: It is a simple minting policy by which your unique precious NFT is\n  minted. It is the same policy used in the [sell_nft](..\/01_sell_nft\/) task.\n\n- `purchase_offer`: Purchase offer validator. The amount of ADA locked in\n  purchase offer UTxOs is fully unlocked if the desired NFT is sold in the\n  transaction. The sold NFT is checked against the configuration in the datum.\n  The datum carries the desired policy id and an optional token name of the\n  asset. If no token name is set, any NFT from the collection is accepted. The\n  redeemer specifies the specific asset that is being sold.\n\n## Off-chain code\n\nAs usual, create a copy of the `player_template.ts` named `player.ts` that you\ncan run with the `deno run --allow-net --allow-read .\/scripts\/run.ts` command.\nThe code that requires modification lies in this file in the appropriate\nsection.\n\nAs always, we recommend examining the rest of the off-chain code, especially the\n`setup()` function in [task.ts](.\/scripts\/task.ts) which can aid in\nunderstanding the setup of this level and provide useful examples of how to\ninteract with the validators."
  },{
    "name": "tipjar_v2",
    "scope": "ctf",
    "repository_url": "https://github.com/vacuumlabs/cardano-ctf",
    "blueprint_url": "https://github.com/vacuumlabs/cardano-ctf/blob/main/06_tipjar_v2/plutus.json",
    "published_date": 1727787600,
    "readme": "# tipjar_v2\n\n**Spoiler alert: Do not attempt this level before solving level 04 -\n[tipjar](..\/04_tipjar\/). This task builds on top of it and reveals the idea of\nthe vulnerability.**\n\nThe code and the goal of this level are both similar to the\n[tipjar](..\/04_tipjar\/). The validator is updated to mitigate two attack vectors\npresent in the previous version. However, we believe that it is still possible\nto perform a DoS attack on the Tip Jar and prevent other people from tipping.\nCan you find and demonstrate the vulnerability?\n\n## Warnings\n\nSome solutions might pass in the emulator but not on the testnet. Always verify\nyour solution on the testnet as well.\n\nIf your solution from the [tipjar](..\/04_tipjar\/) passes here as well, try to go\nback and find a different attack vector for the first version of the tipjar."
  },{
    "name": "multisig_treasury_v2",
    "scope": "ctf",
    "repository_url": "https://github.com/vacuumlabs/cardano-ctf",
    "blueprint_url": "https://github.com/vacuumlabs/cardano-ctf/blob/main/07_multisig_treasury_v2/plutus.json",
    "published_date": 1727787600,
    "readme": "# multisig_treasury_v2\n\n**Spoiler alert:** This level is a direct continuation of\n[Level 03: Multisig Treasury](..\/03_multisig_treasury\/) and contains spoilers\nfor its solution. We recommend solving this level only after successfully\ncompleting Level 03.\n\nThis level once again uses a simple multi-signature treasury. The treasury holds\na certain amount of ADA and is owned by a group of addresses. To release any\nportion of the funds, all its owners must agree. To express their will, they\nsign a Multisig UTxO that specifies the amount to be released and the\ndestination address – where the funds should be released. Most importantly, it\naccumulates signatures as they can sign it across multiple transactions.\n\nTo add more protection to the smart contract, a validation token is introduced.\nFor the multisig UTxO to be accepted and funds be released, the validation token\nmust be present within the UTxO. The validation token can only be minted during\nthe creation of the multisig UTxO, and it validates its datum. To link the\nvalidation token with the multisig UTxO, the token's name must be equal to the\nvalidator hash of the multisig contract.\n\nThe statement is similar to the previous Multisig Treasury level. A treasury\nUTxO is created, locking 10 ADA for two owners – yourself and an another owner.\nTo withdraw the funds, you must provide the treasury validator with a multisig\nUTxO signed by both owners. However, you lack the private key for the second\naddress and can not contact him, making it seemingly impossible to obtain his\nsignature. Can you find a way to bypass the contract and release the funds?\n\n## On-chain code\n\nTwo validators and one minting policy are involved in this task:\n\n- `treasury`: Treasury UTxOs contain ADA, and their datum includes a set of\n  owners. Withdrawal from this UTxO is possible when a multisig UTxO, containing\n  signatures from all treasury owners, is provided.\n\n- `multisig`: Multisig UTxOs contain withdrawal proposals in their datum. A\n  proposal specifies the amount, beneficiary, and a set of addresses that need\n  to sign it. This UTxO collects signatures one by one, allowing any specified\n  address to add its signature in the appropriate transaction. To be validated,\n  the UTxO must contain the proper validation token.\n\n- `validation_token`: Minting policy for the validation token. The token can\n  only be minted when a multisig UTxO with a correct datum is created, and the\n  token must be locked inside the UTxO.\n\nNote that the multisig validator is parameterized with the hash of the treasury\nvalidator, and the treasury contains the hash of the multisig validator in its\ndatum. This ensures that a multisig can only be used with a valid treasury and\nvice versa. The multisig validator is also parametrized with the policy id of\nthe validation token to ensure that it can only be spent if a valid validation\ntoken is present.\n\nIn addition to the validators, `lib\/types.ak` contains the datum and the\nredeemer specifications for both validators. There is also the `lib\/utils.ak`\nutils file containing some of the common parser logic to not polute the checks.\n\n## Off-chain code\n\nAs usual, create a copy of the `player_template.ts` named `player.ts` that you\ncan run with the `deno run --allow-net --allow-read .\/scripts\/run.ts` command.\nThe code that requires modification lies in this file in the appropriate\nsection."
  },{
    "name": "lending",
    "scope": "ctf",
    "repository_url": "https://github.com/vacuumlabs/cardano-ctf",
    "blueprint_url": "https://github.com/vacuumlabs/cardano-ctf/blob/main/08_lending/plutus.json",
    "published_date": 1727787600,
    "readme": "# lending\n\nIn this level, you'll analyze a straightforward peer-to-peer lending platform\nwhere borrowers request loans by creating UTxOs specifying the loan amount (only\nADA is supported) and locking collateral tokens to guarantee repayment. Anyone\ncan fulfill the loan, activating it by sending funds to the borrower. Each loan\nmust be repaid within the specified time frame, along with the specified\ninterest.\n\nUpon loan repayment, borrowers can unlock their collateral, and lenders can\nclaim the repaid ADA. If a loan remains unpaid within the set time frame,\nlenders can claim the locked collateral.\n\nTwo borrowers have requested multiple loans. Your task is to uncover a hidden\nvulnerability and acquire some ADA for yourself. Keep in mind three key\nassumptions:\n\n- Collateral tokens locked in lending UTxOs hold no real value for you; your\n  sole aim is to acquire ADA. Stealing collateral tokens won't lead to a\n  successful pass of the tests. Imagine that there's no market to exchange\n  those.\n- You seek to obtain more ADA than you started with. Merely gaining interest\n  from the loans won't suffice.\n- Locked collateral tokens are invaluable to the borrowers. They are certainly\n  worth more for them than the value borrowed. Even if they suspect foul play,\n  they'll proceed through the lending protocol to reclaim the collateral tokens.\n\n## On-chain code\n\nThe on-chain code comprises two files:\n\n- `lending`: This serves as the primary validator responsible for validating all\n  interactions involving lending UTxOs. Pay close attention to its datum as it's\n  rather intricate, requiring careful parameter configuration for the validator\n  to advance through various stages.\n\n- `collateral_token`: This file contains the minting policy for our collateral\n  tokens. It's utilized by the borrowers. To ensure uniqueness for each user,\n  tokens can only be minted if their asset name matches the hash of the user's\n  signature. In other words, you can't mint collateral tokens that are put as\n  collateral in someone else's loan request.\n\n## Off-chain code\n\nAs usual, create a copy of the `player_template.ts` named `player.ts` that you\ncan run with the `deno run --allow-net --allow-read .\/scripts\/run.ts` command.\nThe code that requires modification lies in this file in the appropriate\nsection.\n\nNote that the code necessitates interaction among different users. The\n`GameData` includes wallets for other users, along with their private keys. **Do\nnot use these private keys** while solving the level. It is not needed. The only\nexception is the `askForRepayment` function, which simulates a borrower seeking\nto unlock their collateral tokens. When provided with the correct collateral\ntoken within the lending UTxO, they will repay it in full. Utilize this function\nsolely to repay the UTxOs created during the setup. Do not exploit any\nvulnerability found within this function. Find a smart contract vulnerability\ninstead.\n\nSee the `player_template.ts` for an example of a single interaction between a\nborrower and a lender."
  },{
    "name": "multisig_treasury_v3",
    "scope": "ctf",
    "repository_url": "https://github.com/vacuumlabs/cardano-ctf",
    "blueprint_url": "https://github.com/vacuumlabs/cardano-ctf/blob/main/09_multisig_treasury_v3/plutus.json",
    "published_date": 1727787600,
    "readme": "# multisig_treasury_v3\n\n**Spoiler alert:** This level is a direct continuation of\n[Level 07: Multisig Treasury v2](..\/07_multisig_treasury_v2\/) and contains\nspoilers for its solution. We recommend solving this level only after\nsuccessfully completing Level 07.\n\nThis level again uses a simple multi-signature treasury. The treasury holds a\ncertain amount of ADA and is owned by a group of addresses. To release any\nportion of the funds, all its owners must agree. To express their will, they\nsign a Multisig UTxO that specifies the amount to be released and the\ndestination address – where the funds should be released. Most importantly, it\naccumulates signatures as they can sign it across multiple transactions.\n\nThe statement is the same as in the previous Multisig Treasury level. A treasury\nUTxO is created, locking 10 ADA for two owners – yourself and an another owner.\nTo withdraw the funds, you must provide the treasury validator with a multisig\nUTxO signed by both owners. However, you lack the private key for the second\naddress and can not contact him, making it seemingly impossible to obtain his\nsignature.\n\n## Changes\n\n**The multisig UTxO validator has been modified** to mitigate a specific attack\nvector that could be exploited in Level 07.\n\n⚠️ However, it's important to note that the remaining attack vector was also\npresent in the Level 07's validator. If you successfully exploited it in the\nprevious level, congratulations! You can find out whether that's the case by\ntrying to run your `player.ts` from the Level 07 in this task. If it passes this\nlevel, we encourage you to return to Level 07 and try to solve it differently\n**without** reading the codebase of this level.\n\nThe on-chain code in this level is the same as in the previous level except for\nthe vulnerability from the Level 07 that is fixed. The off-chain code of this\ntask is exactly the same as before. You can refer to their high-level\ndescriptions\n[in the previous README](..\/07_multisig_treasury_v2\/README.md#on-chain-code)."
  },{
    "name": "king_of_cardano",
    "scope": "ctf",
    "repository_url": "https://github.com/vacuumlabs/cardano-ctf",
    "blueprint_url": "https://github.com/vacuumlabs/cardano-ctf/blob/main/10_king_of_cardano/plutus.json",
    "published_date": 1727787600,
    "readme": "# king_of_cardano\n\nThe King of Cardano is a competition, where the winner gets the opportunity to\nmint his own customized King of Cardano NFT! The rules of the competition are\nsimple — you have to spend more money than your predecessor to overthrow him as\na king. The overthrown king gets all his money back. Whoever is the king once\nthe competition is over is the real king and can mint his NFT.\n\n## On-chain code\n\nThere is a single validator and two minting policies that are involved in this\ntask:\n\n- `king_nft`: The price for the winner. The actual King of Cardano NFT. It can\n  be minted only once and by the current king once the competition is over.\n\n- `king_of_cardano`: The main contract. It allows for three actions:\n  - **OverthrowKing**: Enables you to overthrow the current king and become one.\n  - **CloseCompetition**: The admin uses it to end the competition.\n  - **MintKingNFT**: Once the competition is closed, the final king can use it\n    to mint the NFT.\n\n- `unique_nft`: This is a similar policy used in other tasks as well, for the\n  purpose of minting a unique NFT that can not be minted again. It is modified\n  to allow burning of the token. In this task, it is used in the bootstrapping\n  process: The person that initializes the competition first mints the unique\n  NFT using this policy, then compiles all the other scripts using this NFT as a\n  parameter and puts the NFT itself into the newly created `king_of_cardano`\n  UTxO. In a way, it also serves as a validity token for that UTxO, uniquely\n  identifying the correct competition UTxO.\n\n## Off-chain code\n\nAs usual, create a copy of the `player_template.ts` named `player.ts` that you\ncan run with the `deno run --allow-net --allow-read .\/scripts\/run.ts` command.\n\nThe testing process in this task is as follows:\n\n1. We try to overthrow the current king. You pay for the fees, so you should\n   leave enough ADA in your wallet so that the transaction is feasible. We check\n   that you do. The attempt should fail.\n2. The admin closes the competition. This is a simplification to simulate an\n   accelerated passage of time. Under normal circumstances, no administrative\n   role would be required. This adjustment is made purely for simplification\n   purposes.\n3. We try to claim the King of Cardano NFT on your behalf.\n\nYour aim is to become a king who can not be overthrown and who ultimately claims\na customized King of Cardano NFT. Don't forget to pick a cool nickname :).\n\n## Notes\n\nThis task points to a number of problems and is language specific. There are at\nleast two distinct attack vectors with the stack we chose. The upcoming blogpost\ndiscussing this will discuss three problems this points to. Ultimately, there is\nat least one issue that is an issue in all the common languages — Plutus,\nPlutarch, Aiken. Try to find it. Good luck and have fun!"
  }]
}